# -*- coding: utf-8 -*-
"""10_Taller_Diccionarios (1).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lYV_6uxu94-gknj92-Oabmem616OQbWN

<a href="https://colab.research.google.com/github/LinaMariaCastro/curso-ia-para-economia/blob/main/clases/2_Programacion_en_Python/10_Taller_Diccionarios.ipynb" target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/></a>

# **Inteligencia Artificial con Aplicaciones en Econom√≠a I**

- üë©‚Äçüè´ **Profesora:** [Lina Mar√≠a Castro](https://www.linkedin.com/in/lina-maria-castro)  
- üìß **Email:** [lmcastroco@gmail.com](mailto:lmcastroco@gmail.com)  
- üéì **Universidad:** Universidad Externado de Colombia - Facultad de Econom√≠a

# Taller Programaci√≥n en Python: Diccionarios, range y operadores
---

**IMPORTANTE**: Guarda una copia de este notebook en tu Google Drive o computador.

**Taller en parejas**

**Nombres estudiantes:**

-Miguel Andres Rodriguez
- Daniel Alejandro Caicedo

**Forma de entrega:**

- Registrar las respuestas en https://forms.office.com/r/jNMe8MLbjf para obtener la calificaci√≥n. Vale 20 puntos.

- Publicar Jupyter Notebook con el desarrollo del taller en la cuenta de Github de uno de los estudiantes. Nombrar el archivo de la siguiente forma:‚ÄúTaller_Diccionarios_nombres_y_appellidos.ipynb‚Äù. Esto vale 5 puntos adicionales a las respuestas del formulario.

Puntaje total del taller: 25 puntos.

**Plazo de entrega:**

12 de febrero de 2026, m√°ximo a las 11:59 p.m. Tenga en cuenta que luego de esa hora el formulario en forms se cierra. El Jupupyter Notebook tambi√©n debe quedar subido en Github antes de esa hora.

**Instrucciones Generales:**

Completa el c√≥digo en las celdas marcadas con `### TU C√ìDIGO AQU√ç ###`. Puedes a√±adir m√°s celdas si lo requieres.

**Contexto:**

Has sido contratado por la *Unidad de An√°lisis Macroecon√≥mico* de un banco para automatizar el procesamiento de carteras de cr√©dito y reportes de indicadores econ√≥micos nacionales.

### **Ejercicio 1: Registro de Deudores**
Crea un diccionario llamado `deudor_1` que contenga:
- `nombre`: "Carlos Restrepo"
- `ingresos`: 4500
- `score_crediticio`: 720
"""

### TU C√ìDIGO AQU√ç ###
deudor_1={}
deudor_1["nombre"]="Carlos Restrepo"
deudor_1["ingresos"]=4500
deudor_1["score_crediticio"]=720
print(deudor_1)

"""### **Ejercicio 2: Consulta de Informaci√≥n**
Extrae el valor del `score_crediticio` del cliente Carlos Restrepo y almac√©nalo en una variable llamada `puntaje`.
"""

### TU C√ìDIGO AQU√ç ###
puntaje=deudor_1["score_crediticio"]
print(f"El puntaje es: {puntaje}")

"""### **Ejercicio 3: Actualizaci√≥n de Datos**
Debido a una actualizaci√≥n salarial, cambia los ingresos del cliente Carlos Restrepo a 5200.
"""

### TU C√ìDIGO AQU√ç ###
deudor_1["ingresos"]=5200
print(deudor_1)

"""### **Ejercicio 4: Evaluaci√≥n de Riesgo**
Crea una variable booleana `es_aprobado` que sea `True` si el score del cliente Carlos Restrepo es mayor o igual a 700 y sus ingresos son superiores a 5000.
"""

### TU C√ìDIGO AQU√ç ###
es_aprobado=False
if deudor_1["score_crediticio"]>=700 and deudor_1["ingresos"]>5000:
    es_aprobado=True
print(f"¬øAprobado?: {es_aprobado}")

"""### **Ejercicio 5: Validaci√≥n**
Verifica si la variable `es_aprobado` es estrictamente igual a `True` usando el operador `is`. Guarda el resultado en la variable `check`.
"""

### TU C√ìDIGO AQU√ç ###
check=es_aprobado is True
print(check)

"""### **Ejercicio 6: Agregar Informaci√≥n**
En el diccionario que almacena los datos del cliente Carlos Restrepo, agrega una nueva llave `ciudad` con el valor "Medell√≠n" .
"""

### TU C√ìDIGO AQU√ç ###
deudor_1["ciudad"]="Medellin"
print(deudor_1)

"""### **Ejercicio 7: Borrado de Datos Sensibles**
En el diccionario que almacena los datos del cliente Carlos Restrepo, elimina la informaci√≥n de `score_crediticio`. Usa el m√©todo `.pop()`.
"""

### TU C√ìDIGO AQU√ç ###
deudor_1.pop("score_crediticio")
print(deudor_1)

"""### **Ejercicio 8: Validaci√≥n**
Verifica si en los datos del cliente Carlos Restrepo hay informaci√≥n de sus ingresos. Guarda el resultado booleano en `existe_ingresos`.
"""

### TU C√ìDIGO AQU√ç ###
existe_ingresos="ingresos" in deudor_1
print(existe_ingresos)

"""### **Ejercicio 9: Validaci√≥n**
Usa el m√©todo `.get()` para buscar la llave `"tasa_cambio"` en el diccionario que contiene los datos del cliente Carlos Restrepo. Si no existe, que retorne el valor `4000`. Guarda el resultado en una variable llamada `trm`.
"""

### TU C√ìDIGO AQU√ç ###
trm = deudor_1.get("tasa_cambio", 4000)
print(trm)

"""### **Ejercicio 10: Agregar Informaci√≥n**
Actualiza los datos del cliente Carlos Restrepo agregando al diccionario `{"estrato": 4}`. Usa el m√©todo `.update()`.
"""

### TU C√ìDIGO AQU√ç ###
deudor_1.update({"estrato":4})
print(deudor_1)

"""### **Ejercicio 11: Portafolio**
Crea un diccionario `cartera_bancaria` donde las llaves sean los sectores en los que el banco ofrece pr√©stamos: `"Agro"`, `"Industria"` y `"Vivienda"`, y los valores sean listas con 3 montos de cr√©dito para cada sector, as√≠:
- Montos de cr√©dito para Agro: 100, 200 y 150
- Montos de cr√©dito para Industria: 500, 450 y 600
- Montos de cr√©dito para Vivienda: 300, 320 y 280
"""

### TU C√ìDIGO AQU√ç ###
cartera_bancaria={}
cartera_bancaria["Agro"]=[100, 200, 150]
cartera_bancaria["Industria"]=[500, 450, 600]
cartera_bancaria["Vivienda"]=[300, 320, 280]
print(cartera_bancaria)

"""### **Ejercicio 12: Acceso a un Monto de Cr√©dito Espec√≠fico**
Extrae el segundo monto del sector `"Industria"` en una variable llamada `monto_especifico`.
"""

### TU C√ìDIGO AQU√ç ###
monto_especifico=cartera_bancaria["Industria"][1]
print(monto_especifico)

"""### **Ejercicio 13: Identificaci√≥n de Sectores**
Obt√©n una lista de todos los sectores disponibles en `cartera_bancaria` y gu√°rdala en la variable `sectores`.
"""

### TU C√ìDIGO AQU√ç ###
sectores=[]
for i in cartera_bancaria:
    sectores.append(i)
print(sectores)

"""### **Ejercicio 14: Conteo de Cartera**
Cuenta cu√°ntos sectores hay en `cartera_bancaria` y gu√°rdalo en `n_sectores`.
"""

### TU C√ìDIGO AQU√ç ###
n_sectores=0
for i in cartera_bancaria:
    n_sectores+=1
print(n_sectores)

"""### **Ejercicio 15: Rango de A√±os para el IPC**
Crea una lista llamada `periodo_analisis` que contenga los a√±os desde 2015 hasta 2024 (inclusive).
"""

### TU C√ìDIGO AQU√ç ###
periodo_analisis=list(range(2015, 2025))
print(periodo_analisis)

"""### **Ejercicio 16: Ciclo Pol√≠tico**
Genera una lista con los a√±os en que ha habido elecciones presidenciales en Colombia (cada 4 a√±os) desde 1994 hasta 2026 (inclusive). Gu√°rdalo en una variable llamada `a√±os_elecciones`.
"""

### TU C√ìDIGO AQU√ç ###
a√±os_elecciones=list(range(1994,2027))
print(a√±os_elecciones)

"""### **Ejercicio 17: Informaci√≥n del DANE**
Crea un diccionario llamado `hogar_dane` que contenga el id del hogar y la cantidad de miembros que son adultos y que son ni√±os, as√≠:
- `id`: 101
- `miembros`: un diccionario con las llaves "Adultos" (cuyo valor es 2) y "Ni√±os" (cuyo valor es 1).
"""

### TU C√ìDIGO AQU√ç ###
hogar_dane={}
hogar_dane["id"]=101
hogar_dane["miembros"]={"Adultos":2, "Ni√±os":1}
print(hogar_dane)

"""### **Ejercicio 18: Comparaci√≥n de Inflaci√≥n**
Si `inf_2023 = 9.28` e `inf_2022 = 13.12`, crea una variable `hubo_descenso` que sea `True` si la inflaci√≥n de 2023 fue menor a la de 2022.
"""

### TU C√ìDIGO AQU√ç ###
inf_2023 = 9.28
inf_2022 = 13.12
hubo_descenso=inf_2023<inf_2022
print(hubo_descenso)

"""### **Ejercicio 19: Construcci√≥n de Informaci√≥n Macroecon√≥mica**
Dadas las listas `k = ["PIB", "IPC"]` y `v = [1.2, 0.5]`. Crea un diccionario `indicadores` uniendo ambas listas.
"""

### TU C√ìDIGO AQU√ç ###
k = ["PIB", "IPC"]
v = [1.2, 0.5]
indicadores=dict(zip(k,v))
print(indicadores)

"""### **Ejercicio 20: Vaciado de Informaci√≥n**
Limpia todo el contenido del diccionario `indicadores` dej√°ndolo vac√≠o con el m√©todo `.clear()`.
"""

### TU C√ìDIGO AQU√ç ###
indicadores.clear()
print(indicadores)

"""Ejecuta esta celda al finalizar todo el taller. Si no obtienes ning√∫n error, ¬°felicidades! Tu l√≥gica es correcta. Si obtienes un mensaje de error en la validaci√≥n, revisa los puntos indicados."""

def verificar_taller():
    errores = []

    try:
        if not (isinstance(deudor_1, dict) and "Carlos Restrepo" in deudor_1.values()):
            errores.append("1")
        if not ((puntaje * 2) / 10 == 144.0):
            errores.append("2")
        if not (deudor_1.get("ingresos") == 2600*2 and deudor_1["ingresos"] + 800 == 6000):
            errores.append("3")
        if not (es_aprobado is True):
            errores.append("4")
        if not (check is True):
            errores.append("19")
        if not (deudor_1.get("ciudad") == "Medell√≠n" and len(deudor_1) >= 42/14):
            errores.append("5")
        if not ("score_crediticio" not in deudor_1):
            errores.append("12")
        if not (existe_ingresos is True):
            errores.append("13")
        if not ((trm ** 0.5) == 63.245553203367585):
            errores.append("17")
        if not (deudor_1.get("estrato") == 64/16 and "categoria" not in deudor_1):
             if not (deudor_1.get("estrato") == 64/16):
                errores.append("20")
        if not (len(cartera_bancaria) == 24/8 and isinstance(cartera_bancaria["Agro"], list)):
            errores.append("6")
        if not ((monto_especifico / 3) == 150):
            errores.append("7")
        if not (len(sectores) == 27/9 and "Vivienda" in sectores):
            errores.append("8")
        if not (n_sectores == 3):
            errores.append("18")
        if not (len(periodo_analisis) == 2.5*4 and sum(periodo_analisis) == 20195):
            errores.append("9")
        if not (len(a√±os_elecciones) == 72/8 and a√±os_elecciones[-1] == 2026):
            errores.append("10")
        if not (isinstance(hogar_dane["miembros"], dict) and hogar_dane["miembros"].get("Ni√±os") == 1):
            errores.append("11")
        if not (hubo_descenso is True):
            errores.append("14")
        if not (isinstance(indicadores, dict)):
            errores.append("15")
        if not (len(indicadores) == 0 and isinstance(indicadores, dict)):
            errores.append("16")

    except NameError as e:
        errores.append(f"Variable no definida: {e}")
    except Exception as e:
        errores.append(f"Error de ejecuci√≥n: {str(e)}")

    if not errores:
        print("‚úÖ ¬°Felicidades! El reporte de consultor√≠a es impecable. Todos los ejercicios son correctos.")
    else:
        solo_numeros = [err for err in errores if err.isdigit()]
        errores_var = [err for err in errores if not err.isdigit()]
        mensaje_final = f"‚ùå Se encontraron inconsistencias en los siguientes ejercicios: {', '.join(solo_numeros)}"
        print(mensaje_final)
        if errores_var:
            print(f"{errores_var[0]}")
        print("\nRevisa la l√≥gica de los diccionarios, los l√≠mites de los range o los operadores l√≥gicos e intenta de nuevo.")

verificar_taller()